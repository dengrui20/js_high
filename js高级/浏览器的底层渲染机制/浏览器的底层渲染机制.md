## 浏览器的底层渲染机制
#### 输入域名访问页面
  根据输入的地,获取到对应的html代码(本质获取的是字节，通过浏览器转换成字代码文本)
  客户端从服务器获取到需要渲染的页面的资源的代码后
  浏览器会开辟一个GUI渲染线程,自上而下解析代码
  最后绘制出对应的页面

  **自上而下渲染解析代码的过程是"同步"的, 但是有些操作也是异步的**

##### 1. 关于css资源的加载
   + 遇到\<style> "内联样式"
    + "同步" 交给GUI渲染线程解析

   + 遇到\<link> "外链样式"
      + "异步" 开辟一个新的HTTP网络请求线程,请求资源文件(**同一个源下,根据不同的浏览器,最多只允许同时开辟4~7个HTTP线程, "HTTP的并发数",超过的需要排队等待)**
      + GUI渲染线程同步操作都处理完成以后, 再把基于HTTP网络线程请求回来的资源文件进行解析渲染

   + 遇到@import "导入式样式"
      + "同步" 开辟一个新的HTTP网络请求线程,请求资源文件
      + 但是在资源文件没有请求回来之前, GUI渲染线程会被'阻塞', 不允许其继续向下渲染 

##### 2. 关于script资源的加载
+ 默认都是"同步"的: 必须基于HTTP网络线程,把资源请求回来之后,并且交给"JS渲染线程"渲染解析完成成后,GUI渲染线程才能继续向下渲染,所以\<script>默认也是"阻碍GUI渲染的"

+ async属性: 如果script有 async 属性, 首先也是开辟一个HTTP网络线程去加载资源文件, 但是此时GUI渲染线程继续向下渲染,把默认的同步改为异步, 但是一旦当资源请求回来后, **会中断GUI渲染**, 先把请求回来的js进行渲染解析

+ defer属性: 和async类似, 都是开辟一个HTTP网络线程去加载资源文件,GUI渲染线程继续向下渲染, 但是不一样的地方时, defer和link类似，是在GUI同步的代码渲染完成后,才会渲染解析

##### 3. 关于图片或者音视频资源
+ 遇到这些资源, 也会发送新的HTTP网络线程, 请求加载对应的资源文件, 不会阻碍GUI的渲染「异步」;但是 GUI渲染完成后, 才会把请求回来资源信息进行渲染解析;

`Webkit浏览器预测解析：chrome的预加载扫描器html-preload-scanner通过扫描节点中的 “src” , “link”等属性，找到外部连接资源后进行预加载，避免了资源加载的等待时间，同样实现了提前加载以及加载和执行分离。`


#### 页面渲染的步骤
  + DOM TREE (DOM树): 自上而下渲染完页面, 整理好整个页面的DOM结构关系
  + CSSOM TREE (样式树): 当把<font color="red">所有</font>的样式资源请求加载回来后, 按照CSS引用的顺序, 依次渲染样式代码, 生成样式树
    + 如 link1 link2 如果link2 先加载回来 会等到link1加载回来之后按照link1 -> link2 的顺序进行渲染 
  + RENDER TREE (渲染树): 把生成的DOM树和CSSOM树合并在一起, 生成渲染树 
    + 对于display:none 的元素是不会再渲染树内生成的
  + 布局/回流/重排/layout
    + 根据生成的渲染树, 计算出每个元素相对于视口的大小和方位(计算的过程还没有绘制)
    + 元素的大小或者位置发生了变化(当页面的布局和几何信息发生编发的时候), 触发了重新布局导致渲染树重新计算布局和渲染
  + 分层处理
    + 按照层级定位分层处理, 每一个层级都有详细规划出具体的绘制步骤
  + 绘制/重绘/Painting
    + 按照每一个层级计算处理的绘制步骤, 开始绘制页面
    + 包含图片的绘制

  #### 前端性能优化
  「CRP」关键渲染路径 根据渲染过程,分析出每一步做了什么,对每一步进行优化

  + **生成DOM TREE**
    + 见到DOM的层级嵌套
    + 不要使用非标准的标签
    + ...

  + **生成CSSOM**
    + 尽可能不要使用@import (阻塞GUI渲染)
    + 如果css代码比价少, 尽可能使用"style"内联样式(减少HTTP请求数量,以及渲染css的时候也不需要再计算依赖关系)
    + 如果使用link, 尽可能把所有的样式资源放在一个文件里
    + css选择链短一些(因为css选择器渲染是从右到左)
    + 把link等导入css的操作放在head中(目的是以加载页面就开始请求资源, 同时GUI去生成DOM树, 「css资源预加载」)
    + ...
     
  + **其他资源优化**
    + script尽可能放在页面的地步(防止其阻塞GUI的渲染): 对于部分script 需要使用async和defer
      + async不会考虑js依赖关系, 哪个资源先获取到就先执行哪个js
      + defer不会这样的, 和link一样, 是等到所有script请求回来后, 按照导入/依赖关系依次渲染执行
    + 对于img资源
    + 懒加载: 第一次加载页面的时候不要加载图片, 虽然图片是异步的, 但是也占据的HTTP的并发数量, 导致其他资源延后加载
      + 图片的base64: 不用请求加载图片BASE64码基本上代表的就是图片，而且页面渲染图片的速度也很快, 正常图片下载后 也会转换成base64码
    + Layout/Painting: 重要的优化手段(减少DOM的回流和重绘)
      + 第一次加载页面必然会有一次回流和重绘**
    + 触发回流操作后必然会进行重绘, 单纯重绘不会影响回流,性能优化点，重点都在回流上;
    + DOM元素样式分离读和写
    + 把动画等频发样式改变的操作,运用到position: fixed/absolute上,「脱离文档流: 单独一层
      + 利用分层机制, 如果只改变一个层面上的大小等信息,只会回流和重绘当前一层的DOM, 浏览器回流和重绘的速度会加快很多
    + css3硬件加速(GPU加速)
      + 通过 transform/opcity... 修改这些样式的操作不会引发DOM的回流, 浏览器的硬件加速, 弊端就是小号浏览器的内存
    + 以下操作都需要浏览器重新计算每一个元素在视口中的位置和大小（Layout）
      + 元素在饰扣中的大小或者位置发生变化
      + 元素的删除或者新增(基于display控制显示隐藏)
      + 浏览器视口大小发生改变
      + ...

   `当代浏览器的渲染队列机制: 在当前上下文操作中, 遇到一行修改样式的代码, 并没有立即通知浏览器,而是把其防止在渲染队列中, 接下来看是否还有修改样式的代码, 如果有继续放置在渲染队列中,一直到再也没有修改样式的代码或者"<font color="red">遇到一行获取样式的操作</font>", 这样都会刷新浏览器的渲染队列机制`
   ```javascript
    box.style.height = "100px"
    box.style.height = "200px"
    box.style.position = "absolute"
    box.style.top = "100px"
    // 执行完成之后 会将所有修改页面样式其放入渲染队列代码
    // 最后统一进行渲染

    box.style.height = "100px"
    box.style.height = "200px"
    console.log(window.getComputedStyle(box).offsetWidth)
    box.style.position = "absolute"
    box.style.top = "100px"
    // window.getComputedStyle(box).offsetWidth
    // 这一行获取了样式, 就会强行进行渲染, 从而触发回流
    // 最后执行完 box.style.top = "100px" 后
    // 后面没有修改样式的代码, 就会再次触发一次回流  

    // 样式分离读写


   ```