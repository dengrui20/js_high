## 宏任务和微任务
#### 宏任务
宏任务包括
  + 渲染事件（如解析 DOM、计算布局、绘制）
  + 用户交互事件（如鼠标点击、滚动页面、放大缩小等）
  + JavaScript 脚本执行事件
  + 网络请求完成、文件读写完成事件
  + ...

我们把这些消息队列中的任务称为**宏任务**


#### 微任务

**微任务**就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前

 JavaScript 执行一段脚本的时候，V8 会为其创建一个全局执行上下文，在创建全局执行上下文的同时，V8 引擎也会在内部创建一个微任务队列。顾名思义，这个微任务队列就是用来存放微任务的，因为在当前宏任务执行的过程中，有时候会产生多个微任务，这时候就需要使用这个微任务队列来保存这些微任务了。不过这个微任务队列是给 V8 引擎内部使用的，所以你是无法通过 JavaScript 直接访问的

 每个宏任务都关联了一个微任务队列


在当前宏任务中的 JavaScript 快执行完成时，也就在 JavaScript 引擎准备退出全局执行上下文并清空调用栈的时候，JavaScript 引擎会检查全局执行上下文中的微任务队列，然后按照顺序执行队列中的微任务。**WHATWG 把执行微任务的时间点称为检查点**

**执行微任务的过程中，产生了新的微任务**，同样会将该微任务添加到微任务队列中，V8 引擎一直循环执行微任务队列中的任务，直到队列为空才算执行结束。也就是说在执行微任务过程中产生的新的微任务并不会推迟到下个宏任务中执行，而是在当前的宏任务中继续执行



+ 微任务和宏任务是绑定的，每个宏任务在执行时，会创建自己的微任务队列。
+ 微任务的执行时长会影响到当前宏任务的时长。比如一个宏任务在执行过程中，产生了100 个微任务，执行每个微任务的时间是 10 毫秒，那么执行这 100 个微任务的时间就是 1000 毫秒，也可以说这 100 个微任务让宏任务的执行时间延长了 1000 毫秒。所以你在写代码的时候一定要注意控制微任务的执行时长。
+ 在一个宏任务中，分别创建一个用于回调的宏任务和微任务，无论什么情况下，微任务都早于宏任务执行


```js
  function executor(resolve, reject) {
    let rand = Math.random();
    console.log(1)
    console.log(rand)
    if (rand > 0.5) resolve()
    else reject()
  }
  var p0 = new Promise(executor);
  var p1 = p0.then((value) => {
    console.log("succeed-1")
    return new Promise(executor)
  })
  var p3 = p1.then((value) => {
    console.log("succeed-2")
    return new Promise(executor)
  })
  var p4 = p3.then((value) => {
    console.log("succeed-3")
    return new Promise(executor)
  })
  p4.catch((error) => {
    console.log("error")
  })
  console.log(2)
````