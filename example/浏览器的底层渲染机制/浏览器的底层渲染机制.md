## 浏览器的底层渲染机制
#### 输入域名访问页面
  根据输入的地,获取到对应的html代码
  客户端从服务器获取到需要渲染的页面的资源的代码后
  浏览器会开辟一个GUI渲染线程,自上而下解析代码
  最后绘制出对应的页面

  **自上而下渲染解析代码的过程是"同步"的, 但是有些操作也是异步的**

##### 1. 关于css资源的加载
   + 遇到\<style> "内联样式"
   + + "同步" 交给GUI渲染线程解析

   + 遇到\<link> "外链样式"
   + + "异步" 开辟一个新的HTTP网络请求线程,请求资源文件(**同一个源下,根据不同的浏览器,最多只允许同时开辟4~7个HTTP线程, "HTTP的并发数",超过的需要排队等待)**
   + + GUI渲染线程同步操作都处理完成以后, 再把基于HTTP网络线程请求回来的资源文件进行解析渲染

   + 遇到@import "导入式样式"
   + + "同步" 开辟一个新的HTTP网络请求线程,请求资源文件
   + + 但是在资源文件没有请求回来之前, GUI渲染线程会被'阻塞', 不允许其继续向下渲染 

##### 2. 关于script资源的加载
+ 默认都是"同步"的: 必须基于HTTP网络线程,把资源请求回来之后,并且交给"JS渲染线程"渲染解析王成后,GUI渲染线程才能继续向下渲染,所以\<script>默认也是"阻碍GUI渲染的"

+ async属性: 如果script有 async 属性, 首先也是开辟一个HTTP网络线程去加载资源文件, 但是此时GUI渲染线程继续向下渲染,把默认的同步改为异步, 但是一旦当资源请求回来后, **会中断GUI渲染**, 先把请求回来的js进行渲染解析

+ defer属性: 和async类似, 都是开辟一个HTTP网络线程去加载资源文件,GUI渲染线程继续向下渲染, 但是不一样的地方时, defer和link类似，是在GUI同步的代码渲染完成后,才会渲染解析

##### 3. 关于图片或者音视频资源
+ 遇到这些资源, 也会发送新的HTTP网络线程, 请求加载对应的资源文件, 不会阻碍GUI的渲染「异步」;但是 GUI渲染完成后, 才会把请求回来资源信息进行渲染解析;

==Webkit浏览器预测解析：chrome的预加载扫描器html-preload-scanner通过扫描节点中的 “src” , “link”等属性，找到外部连接资源后进行预加载，避免了资源加载的等待时间，同样实现了提前加载以及加载和执行分离。==